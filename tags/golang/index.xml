<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Manabie Tech Blog</title><link>/tags/golang/</link><description>Recent content in Golang on Manabie Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Except where otherwise noted, content on this site is licensed under a [Creative Commons Attribution 4.0 International license](https://creativecommons.org/licenses/by-sa/4.0/).</copyright><lastBuildDate>Wed, 20 Oct 2021 14:28:23 +0700</lastBuildDate><atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Snapshot test your Postgresql in Golang pgx driver</title><link>/2021/10/snapshot-test-your-postgresql-in-golang-pgx-driver/</link><pubDate>Wed, 20 Oct 2021 14:28:23 +0700</pubDate><guid>/2021/10/snapshot-test-your-postgresql-in-golang-pgx-driver/</guid><description>If your unit-test understand SQL syntax, you can cover many behaviors of your code without the need of starting a real DB. Want to understand Postgresql syntax? just simply import Postgresql parser to your program, https://github.com/pganalyze/pg_query_go helps you to do that.
How about using a containerized DB? Sometimes, the repository layer doesn&amp;rsquo;t have much logic (maybe concat some WHERE conditions), only propagate the SQL statement to DB.
Testing with a simple containerized DB is a good option where you can:</description></item></channel></rss>