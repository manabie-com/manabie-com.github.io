<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:title" content="J4 stress test framework"><meta property="og:description" content="An incubating stress test framework written in Golang"><meta property="og:type" content="article"><meta property="og:url" content="/2022/08/j4-stress-test-framework/"><meta property="article:published_time" content="2022-08-23T17:10:49+07:00"><meta property="article:modified_time" content="2022-08-24T10:48:39+07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="J4 stress test framework"><meta name=twitter:description content="An incubating stress test framework written in Golang"><meta name=generator content="Hugo 0.126.0"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"J4 stress test framework","url":"/2022/08/j4-stress-test-framework/","wordCount":"1790","datePublished":"2022-08-23T17:10:49+07:00","dateModified":"2022-08-24T10:48:39+07:00","author":{"@type":"Person","name":"duongcongtoai"},"keywords":"DevSecOps, Testing, Stress Test, Kubernetes, Golang, Raft","description":"An incubating stress test framework written in Golang"}</script><link rel=canonical href=/2022/08/j4-stress-test-framework/><title>J4 stress test framework | Manabie Tech Blog</title>
<link href=/css/style.beb8012edc08ba10be012f079d618dc243812267efe62e11f22fe49618f976a4.css rel=stylesheet integrity="sha256-vrgBLtwIuhC+AS8HnWGNwkOBImfv5i4R8i/klhj5dqQ=" crossorigin=anonymous><script defer src=/js/fontawesome.min.f5072c55a0721857184db93a50561d7dc13975b4de2e19db7f81eb5f3fa57270.js integrity="sha256-9QcsVaByGFcYTbk6UFYdfcE5dbTeLhnbf4HrXz+lcnA=" crossorigin=anonymous></script><script src=/js/haven.umd.min.5f4a3edd16edd243f2a9b07dbf1b371f8f1b18fbb29319aba09431678609a175.js integrity="sha256-X0o+3Rbt0kPyqbB9vxs3H48bGPuykxmroJQxZ4YJoXU=" crossorigin=anonymous></script><script>Haven.create({notification:{styles:{background:"#428bca",textColor:"#ffffff",buttonBackgroundColor:"#f71559",buttonTextColor:"#ffffff"}},translations:{en:{notification:{policy:"Learn more.",message:"This website uses cookies.",accept:"Agree",decline:"Disagree"}}},services:[{name:"google-analytics",options:{id:"G-EJ2GNQJNM6"},purposes:["analytics"],inject:!0}]})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EJ2GNQJNM6"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EJ2GNQJNM6")}</script><style>div.highlight>pre{padding:1rem}</style></head><body><div class=blog-masthead><div class=container><nav class="nav blog-nav"><a class=nav-link href=/>Home</a></nav></div></div><header class=blog-header><div class=container><h1 class=blog-title dir=auto><a href=/ rel=home>Manabie Tech Blog</a></h1><p class="lead blog-description" dir=auto>Sharing the humble technical knowledge we&rsquo;re using to improve education</p></div></header><div class=container><div class=row><div class="col-sm-8 blog-main"><article class=blog-post><header><h2 class=blog-post-title dir=auto><a href=/2022/08/j4-stress-test-framework/>J4 stress test framework</a></h2><p class=blog-post-meta><time datetime=2022-08-23T17:10:49+07:00>Tue Aug 23, 2022</time>
in
<span class="fas fa-folder" aria-hidden=true></span>&nbsp;<a href=/categories/devsecops/ rel="category tag">DevSecOps</a>, <a href=/categories/testing/ rel="category tag">Testing</a>
<span class="fas fa-tag" aria-hidden=true></span>&nbsp;<a href=/tags/stress-test/ rel=tag>Stress Test</a>, <a href=/tags/kubernetes/ rel=tag>Kubernetes</a>, <a href=/tags/golang/ rel=tag>Golang</a>, <a href=/tags/raft/ rel=tag>Raft</a></p></header><h2 id=why-stress-test>Why stress test</h2><p>At Manabie, we have already implemented bunch of features for the business, mostly to support ERP in education domain. The traffic on production is not that high. For each cluster (of each clients), it barely reaches 100 rpc on our Grafana dashboard, and everything looks safe.
But no, we realize that in our roadmap, we have a plan to merge all the cluster into a multi-tenant cluster. We don&rsquo;t know if the cluster merge will affect some resources, maybe there are extensively used features that we will not be aware of (features team are rapidly adding more APIs, as the business grows) and we may encouter performance issues unprepared. And thus we have an epic to plan for stress test in our Kanban dashboard.</p><h2 id=why-another-framework>Why another framework</h2><p>What we want:</p><ul><li>Programmable interface (Golang): In Manabie, we write a lot of integration test using Golang, it is already a normal routine of every developer, and stress testing script is just another integration test script, but with high load and orchestrated by the stress test framework. Thus, we want our developer to feel indifference between writing integration test and stress test. Another reason for using programmable interface is that we want to inject custom metadata into the stressed test requests such as prometheus client side metrics, or Jaeger trace.</li><li>Freedom of protocol: In Manabie we use different types of protocol: Grpc/Restful/Graphql. The framework should support or allow us to provide implementation for those protocols.</li><li>Scalable deployment together with K8S: this is a quality we want in a framework (even though we may don&rsquo;t need it right now), that it can scale and integrate well with K8S ecosystem. We want to provide utility to our developer to stress test their service without complex setup: how many request to simulate, how fast the rpc increase, gradually or exponentially,&mldr; And the framework should behave correctly with what it promise. In order to do that, it must be deployed in cluster mode, into multiple containers with certain level of fault tolerant (aka one worker goes down, the workload must be handled by another newly spawned worker)</li></ul><p>K6s and Locust are good options but they do not provide the option for a Golang friendly programmable interface. You may argue that language does not matter, but for us in this case it does.</p><p>Thus, J4 (Jarvan IV) was born</p><h2 id=incubating-j4-the-stress-test-framework>Incubating J4 the stress test framework</h2><p><img alt=J4 src=./images/j4-icon.png></p><h3 id=core-concept>Core concept</h3><h4 id=scenario>Scenario:</h4><p>A scenario needs to (partially) make simulating requests, aka the requests the server have to serve if it were real user interactions. For example, for a chat feature, in order to have a chat, a user account must be created first, and then if that account is a student, then the system automatically create the chat for that students. There are of course a lot of business logic hidden inside the scenario, and we the platform team cannot write them all. It is the responsibility of feature developing teams. And example of a scenario used to stress the chat server looks like:</p><ul><li>create user account</li><li>retrieve user token</li><li>get the user&rsquo;s chat id</li><li>create a session to the chat server (in our case is Grpc Server side streaming)</li><li>establish a dedicated pinging routine to keep the previous session alive (this sounds weird, we have to do this pinging stuff for other reason that we can&rsquo;t explain in this article)</li><li>after each interval, make a send message requests to the server</li><li>in the meantime, if the stream receive the message, the stress test also need to receive it and maybe make some metrics from that information.</li></ul><p>There are several issues with this approach is that:</p><ul><li>The framework must spam requests really fast, thus it need a pool of precreated user accounts. Else, by stress testing chat module, we accidentally stress test other modules (user module, firebase, &mldr;.).</li><li>The stream can be disconnected during the stress test, the scenario must be written to cover this case, that it will reconnect to the server if the stream is disconnected.
=> The logic is not simple, and it is hard for a generic framework do support us this requirement from end to end.</li></ul><h4 id=worker>Worker</h4><p>This is an execution unit of J4 framework, it is just a for loop inside Golang that simultaneously executes a user defined function, something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>myscenarioFunction</span>(<span style=color:#a6e22e>childCtx</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>J4 also provides user option to use closure to create the scenario function, to initialize some customized logic. We may need more sophisticated hooks later, but for now we only provide a simple closure to framework user.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myscenarioClosure</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>userID</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getSomeUserFromPool</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>streamID</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>createChatStreamForUser</span>(<span style=color:#a6e22e>userID</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>pingToKeepStreamAlive</span>(<span style=color:#a6e22e>userID</span>,<span style=color:#a6e22e>streamID</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sendMessageToChat</span>(<span style=color:#a6e22e>userID</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>myscenarioFunction</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>myscenarioClosure</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>myscenarioFunction</span>(<span style=color:#a6e22e>childCtx</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=cycles>Cycles</h4><p>J4 organizes a scenario lifetime into 3 phases:</p><p>Rampup -> Hold -> Rampdown</p><p>Rampup: this phase is broken down into rampup cycles. After a configurable interval, the framework spawns a fixed number of goroutines, call workers. This makes the test create an increasing stress to the server (linearly). Rampup cycle ends when the targetcount of workers is reached.</p><p>Hold: during this period, the number of spawned workers are kept alive to do their job, making requests, making requests, making requests&mldr; The hold cycle ends after
a configurable duration.</p><p>Ramdown: during this period, the framework gradually shutdown the spawned workers, also by a fixed number of workers after a configurable interval.</p><h3 id=cluster-mode>Cluster mode</h3><p>There are 2 types of nodes in a J4 cluster: distributor and executor</p><h4 id=task-distributor>Task distributor</h4><p>This node receive the definition of scenario (cycle definition, target count, rampup delay &mldr;)
On the receipt of the scenario, it store the scenario info into a storage (rqlite), and distribute the workload to current executor.
If a new executor is added to the cluster, based on service discovery, the distributor reacts to this event by redistributing the load of current running scenarios, like &ldquo;hey new guys have joined, you guys go ahead and update the tasks you have to do, if you have spawned more than you need, kill some goroutines, else, adjust the target count and only spawn up to that number&rdquo;</p><h4 id=task-executor>Task executor</h4><p>This node is the one that actually runs the function defined by the scenario.</p><p>Each executor must obey what the distributor tells them, how much, how fast to spawn the workload.</p><h3 id=naive-implementation-of-leader-election>Naive implementation of leader election</h3><p>Currently we deploy all J4 nodes using the same configuration, but at runtime, one J4 must become the task distributor. Luckily, our storage that J4 uses is rqlite which has a RAFT module underneath => we borrow the function of leader election of RAFT to decide which J4 will become the task allocator.</p><p>This looks bad, because we layer above should not make assumption about the implementation of the layer beneath, which J4 does. But at least we have what we need immediately.</p><h3 id=observability>Observability</h3><h4 id=client-side-metrics-gathering>Client side metrics gathering</h4><p>J4 tries to support multiple protocol, including Grpc/HTTP/Grahql. The developers that write the stress test script must use the library provided by platform team, so that we can help them gather client side metrics in a generic fashion, for example, this is the code sample that inject some grpc client side metrics:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> 	<span style=color:#e6db74>&#34;go.opencensus.io/tag&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>injectCustomTagInterceptor</span>(<span style=color:#a6e22e>tagKey</span> <span style=color:#a6e22e>tag</span>.<span style=color:#a6e22e>Key</span>, <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>UnaryClientInterceptor</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>method</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>reply</span> <span style=color:#66d9ef>interface</span>{},
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>ClientConn</span>, <span style=color:#a6e22e>invoker</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>UnaryInvoker</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>CallOption</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>newCtx</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tag</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>tag</span>.<span style=color:#a6e22e>Insert</span>(<span style=color:#a6e22e>tagKey</span>, <span style=color:#a6e22e>value</span>))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>invoker</span>(<span style=color:#a6e22e>newCtx</span>, <span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>reply</span>, <span style=color:#a6e22e>cc</span>, <span style=color:#a6e22e>opts</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>commonDialOptions</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>DialOption</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithBlock</span>(),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithStatsHandler</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tracer</span>.<span style=color:#a6e22e>B3Handler</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>ClientHandler</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ocgrpc</span>.<span style=color:#a6e22e>ClientHandler</span>{},
</span></span><span style=display:flex><span>		}),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithChainUnaryInterceptor</span>(<span style=color:#a6e22e>injectCustomTagInterceptor</span>(<span style=color:#a6e22e>j4</span>.<span style=color:#a6e22e>ScenarioKey</span>, <span style=color:#a6e22e>scenarioName</span>)),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>commonDialOptions</span> = append(<span style=color:#a6e22e>commonDialOptions</span>, <span style=color:#a6e22e>opts</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>Dial</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>commonDialOptions</span><span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>This is the function that create a grpc connection to stress test some GRPC API for a scenario with name &ldquo;scenarioName&rdquo;. The interceptor inject the scenarioname into the context, which will later on will be collected by the metrics collector. This will allow the metrics to be filtered by scenario name, for example
<img alt="Metrics by scenario" src=./images/metrics-by-scenario.png>
This is a dashboard that shows all RPC by scenario name, in this case we have run J4 with a scenario named &ldquo;tom&rdquo;, our chat service.</p><h3 id=general-service-metrics>General service metrics</h3><p>These are default metrics platorm team prepare for each service, including:</p><ul><li>RPC</li><li>Latency P99,P95,P90</li><li>Error rate</li><li>Request distribution on pods</li><li>CPU usage</li><li>Memory usage</li><li>Asynchronous messages metrics</li></ul><h4 id=team-specific-metrics>Team specific metrics</h4><p>These are metrics created by the feature team to measure their own service. For example, chat team can measure the latency of message delivery, from the point the SendMessage request is established to the point the users in the chat receive that message in realtime. Those can not be controlled by platform team and have to be measured independently.</p><p>Example of team-spefific metric
<img alt="chat metrics" src=./images/custom-metrics.png></p><h2 id=room-for-improvement>Room for improvement</h2><h3 id=isolate-abtraction-layers>Isolate abtraction layers</h3><p>Relying on RAFT has caused us some troubles deploying J4 cluster (we still have bugs, and bugs in consensus are painful to discover). A lot of times, the whole cluster fails to elect a leader, because of random events causing the container to crash all over the place (dns resolver delay, leader timeout causing new leader to be elected &mldr;), we can&rsquo;t explain all of them here, but we know that having a RAFT cluster that can add/remove nodes dynamically takes more than it gives.
For every J4 node, no matter what role it is (distributor or executor) we always embed a node of rqlite to it. Thus, we caused unnecesary overhead:</p><ul><li>10 nodes in a healthy RAFT cluster means that the leader node needs to send heart beat to 9 other nodes, if if any data mutation happen, the leader also has to replicate its state change to those nodes.</li><li>J4 storage layer uses rqlite to retrieve data of scenario, tasks to execute,.. But after all, read requests always go to the leader node => the replicated data in the follower rqlite is only used for high availability in case the leader fails to connect. 10 backup nodes are unnecesary.</li></ul><p>Although we may need many J4 nodes to execute the tasks, we don&rsquo;t actually need that much node to be highly-available. We realized that we have misunderstood some types of high-availability we want:</p><ul><li>highly available storage (rqlite)</li><li>highly available task allocator (currently also the rqlite node that is firstly elected as leader)</li><li>somewhat highly available workers</li></ul><p>So, the enhanced version of J4 should be able to answer, what happen if one of those entities fail, and how to recover or setup a backup instance.</p><h3 id=robust-task-distribution>Robust task distribution</h3><p>At runtime, tasks executor can also fail (either crash or network partition). The task distributor need to recognize such event and redistribute tasks to the rest of current avaiable executors, or maybe spawn new ones if needed.</p><h2 id=reference>Reference</h2><ul><li><a href=https://raft.github.io/raft.pdf>RAFT paper</a></li><li><a href=https://k6.io/>K6S</a></li></ul><hr><footer><div class=meta_item><span class=meta_text>About <a href=/author/duongcongtoai>duongcongtoai</a></span><br><i>I liked building stuffs</i><br><span class=meta_text><a href=https://github.com/duongcongtoai target=_blank>https://github.com/duongcongtoai</a></span></div><hr><section><h4>Share</h4><nav class="nav sharing-icons"><a class=nav-item href="https://www.facebook.com/sharer/sharer.php?u=%2f2022%2f08%2fj4-stress-test-framework%2f" title="Share on Facebook"><span class="fab fa-facebook-f fa-2x" aria-hidden=true></span></a>
<a class=nav-item href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2f2022%2f08%2fj4-stress-test-framework%2f" title="Share on LinkedIn"><span class="fab fa-linkedin-in fa-2x" aria-hidden=true></span></a>
<a class=nav-item href="https://twitter.com/intent/tweet?url=%2f2022%2f08%2fj4-stress-test-framework%2f&amp;text=J4%20stress%20test%20framework" title="Tweet this"><span class="fab fa-twitter fa-2x"></span></a></nav></section><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//manabie.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="col-sm-3 ml-auto blog-sidebar"><section class=sidebar-module><h4>Links</h4><ol class=list-unstyled><li><a href=https://manabie.com>About Us</a></li><li><a href=https://manabie.breezy.hr>Careers</a></li></ol></section></aside></div></div><footer class=blog-footer><p dir=auto>Except where otherwise noted, content on this site is licensed under a <a href=https://creativecommons.org/licenses/by-sa/4.0/>Creative Commons Attribution 4.0 International license</a>.</p><p><a href=#>Back to top</a></p></footer></body></html>