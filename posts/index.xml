<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Manabie Tech Blog</title><link>/posts/</link><description>Recent content in Posts on Manabie Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Except where otherwise noted, content on this site is licensed under a [Creative Commons Attribution 4.0 International license](https://creativecommons.org/licenses/by-sa/4.0/).</copyright><lastBuildDate>Mon, 13 Dec 2021 14:37:23 +0700</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Why we use Cucumber for end-to-end testing?</title><link>/2021/12/why-we-use-cucumber-for-end-to-end-testing/</link><pubDate>Mon, 13 Dec 2021 14:37:23 +0700</pubDate><guid>/2021/12/why-we-use-cucumber-for-end-to-end-testing/</guid><description>Why we use Cucumber for end-to-end testing? Before getting to know why we use cucumber for End-to-end testing. Let&amp;rsquo;s understand what&amp;rsquo;s end-to-end testing and cucumber are.
What is End to end testing? End to end testing (E2E testing) is a software testing method that validates the entire software. From the beginning to the end.
The purpose of end-to-end testing is to simulate how a real user interacts with the application, list out the scenarios, and test the whole software for dependencies, data integrity and communication with other systems, interfaces, network connectivity and databases to exercise complete production like scenario.</description></item><item><title>Simulate Letâ€™s Encrypt certificate issuing in local Kubernetes</title><link>/2021/11/simulate-https-certificates-acme-k8s/</link><pubDate>Tue, 23 Nov 2021 14:28:23 +0700</pubDate><guid>/2021/11/simulate-https-certificates-acme-k8s/</guid><description>We write test to make sure our code work as expected, no matter that a Go code or YAML config. In this series, we will show how we develop and do integration tests using local k8s. The first part will show how we simulate the HTTPS certificate issue flow to allow our Platform engineers to test their config and allow our Front-end engineers to connect their application to local server with a self-signed HTTPS certificate.</description></item><item><title>Snapshot test your Postgresql in Golang pgx driver</title><link>/2021/10/snapshot-test-your-postgresql-in-golang-pgx-driver/</link><pubDate>Wed, 20 Oct 2021 14:28:23 +0700</pubDate><guid>/2021/10/snapshot-test-your-postgresql-in-golang-pgx-driver/</guid><description>If your unit-test understand SQL syntax, you can cover many behaviors of your code without the need of starting a real DB. Want to understand Postgresql syntax? just simply import Postgresql parser to your program, https://github.com/pganalyze/pg_query_go helps you to do that.
How about using a containerized DB? Sometimes, the repository layer doesn&amp;rsquo;t have much logic (maybe concat some WHERE conditions), only propagate the SQL statement to DB.
Testing with a simple containerized DB is a good option where you can:</description></item></channel></rss>