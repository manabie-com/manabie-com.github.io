<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:title" content="Test Coverage of Go Services during Integration Tests"><meta property="og:description" content="After we build our microservices to collect code coverage and run integration tests on them, we merge our code coverage from the kubernetes containers to get a final coverage figure"><meta property="og:type" content="article"><meta property="og:url" content="/2021/12/integration-test-code-coverage-in-go/"><meta property="article:published_time" content="2021-12-27T17:10:49+07:00"><meta property="article:modified_time" content="2021-12-28T09:37:41+07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Test Coverage of Go Services during Integration Tests"><meta name=twitter:description content="After we build our microservices to collect code coverage and run integration tests on them, we merge our code coverage from the kubernetes containers to get a final coverage figure"><meta name=generator content="Hugo 0.102.1"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Test Coverage of Go Services during Integration Tests","url":"/2021/12/integration-test-code-coverage-in-go/","wordCount":"971","datePublished":"2021-12-27T17:10:49+07:00","dateModified":"2021-12-28T09:37:41+07:00","author":{"@type":"Person","name":"ds0nt"},"keywords":"DevSecOps, Testing, Kubernetes, Docker, integration-test, Golang, microservices, code-coverage","description":"After we build our microservices to collect code coverage and run integration tests on them, we merge our code coverage from the kubernetes containers to get a final coverage figure"}</script><link rel=canonical href=/2021/12/integration-test-code-coverage-in-go/><title>Test Coverage of Go Services during Integration Tests | Manabie Tech Blog</title><link href=/css/style.beb8012edc08ba10be012f079d618dc243812267efe62e11f22fe49618f976a4.css rel=stylesheet integrity="sha256-vrgBLtwIuhC+AS8HnWGNwkOBImfv5i4R8i/klhj5dqQ=" crossorigin=anonymous><script defer src=/js/fontawesome.min.f5072c55a0721857184db93a50561d7dc13975b4de2e19db7f81eb5f3fa57270.js integrity="sha256-9QcsVaByGFcYTbk6UFYdfcE5dbTeLhnbf4HrXz+lcnA=" crossorigin=anonymous></script>
<script src=/js/haven.umd.min.5f4a3edd16edd243f2a9b07dbf1b371f8f1b18fbb29319aba09431678609a175.js integrity="sha256-X0o+3Rbt0kPyqbB9vxs3H48bGPuykxmroJQxZ4YJoXU=" crossorigin=anonymous></script>
<script>Haven.create({notification:{styles:{background:"#428bca",textColor:"#ffffff",buttonBackgroundColor:"#f71559",buttonTextColor:"#ffffff"}},translations:{en:{notification:{policy:"Learn more.",message:"This website uses cookies.",accept:"Agree",decline:"Disagree"}}},services:[{name:"google-analytics",options:{id:"G-EJ2GNQJNM6"},purposes:["analytics"],inject:!0}]})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EJ2GNQJNM6"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EJ2GNQJNM6",{anonymize_ip:!1})}</script><style>div.highlight>pre{padding:1rem}</style></head><body><div class=blog-masthead><div class=container><nav class="nav blog-nav"><a class=nav-link href=/>Home</a></nav></div></div><header class=blog-header><div class=container><h1 class=blog-title dir=auto><a href=/ rel=home>Manabie Tech Blog</a></h1><p class="lead blog-description" dir=auto>Sharing the humble technical knowledge we&rsquo;re using to improve education</p></div></header><div class=container><div class=row><div class="col-sm-8 blog-main"><article class=blog-post><header><h2 class=blog-post-title dir=auto><a href=/2021/12/integration-test-code-coverage-in-go/>Test Coverage of Go Services during Integration Tests</a></h2><p class=blog-post-meta><time datetime=2021-12-27T17:10:49+07:00>Mon Dec 27, 2021</time>
in
<span class="fas fa-folder" aria-hidden=true></span>&nbsp;<a href=/categories/devsecops/ rel="category tag">DevSecOps</a>, <a href=/categories/testing/ rel="category tag">Testing</a>
<span class="fas fa-tag" aria-hidden=true></span>&nbsp;<a href=/tags/kubernetes/ rel=tag>Kubernetes</a>, <a href=/tags/docker/ rel=tag>Docker</a>, <a href=/tags/integration-test/ rel=tag>integration-test</a>, <a href=/tags/golang/ rel=tag>Golang</a>, <a href=/tags/microservices/ rel=tag>microservices</a>, <a href=/tags/code-coverage/ rel=tag>code-coverage</a></p></header><h1 id=test-coverage-of-go-services-during-integration-tests>Test Coverage of Go Services during Integration Tests</h1><p>In Golang, getting code coverage with <code>go test</code> is easy. But it&rsquo;s still rather hard for integration tests.</p><p>Here I want to introduce the method we used at Manabie to measure the code covered by our <em>integration</em> tests across many microservices.</p><h2 id=about-our-integration-tests>About our integration tests</h2><p>At Manabie we use Kubernetes for container orchestration. To perform integration tests, we deploy our services, and then run a test container with a go program with a whole lot of integration tests.</p><p>On dev environments, we start up minikube, deploy the services, and then run the test container as well. In CI, we start a vcluster instead of a minikube.</p><p>Collecting coverage in this setting is a little more complicated, but doable. The main idea is to compile the services with <code>go test -cover</code> instead of <code>go build</code>, and then get the services to exit in a timely manner after testing is finished.</p><p><strong>What&rsquo;s Coming Up</strong></p><p>Part 1:</p><ul><li>compile services with <code>go test -c</code>,</li><li>add an http killswitch</li></ul><p>Part 2:</p><ul><li>run services & run tests</li><li>stop the services by calling the http killswitch endpoint</li></ul><p>Part 3:</p><ul><li>collect coverage reports from containers</li><li>merge them with gocovmerge.</li><li>get a code coverage percent.</li></ul><p>Conclusion & <a href=https://github.com/manabie-com/manabie-com.github.io/blob/main/content/posts/integration-test-code-coverage-in-go/examples>Example Code</a></p><h2 id=part-i-compiling-services-with-go-test-instrumentation>Part I: Compiling services with go test instrumentation</h2><p>We want to run our service with <code>go test</code> so we can use it&rsquo;s <code>cover</code> flags to enable code coverage output.</p><p>To do this, we need to first create a test function that works like our <code>func main()</code>, so that we can use <code>go test</code> to run our server.</p><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>Run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>becomes</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>Run</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>so that we can write a test like this that starts the server:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestRun</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For the coverage to be output, <code>TestRun</code> function needs to finish. We can&rsquo;t just kill the process, or go test will not output a coverage profile.</p><p>Because the service does not know when the tests are complete, we have to set up a mechanism to stop it remotely. We can set up a simple HTTP server. When it gets a request, it will gracefully terminate our service. Later, we can call it with curl.</p><p>Our Kill HTTP server calls a context&rsquo;s <code>CancelFunc</code> when it receives a request.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>killServer</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>server</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cancel</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>CancelFunc</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newKillServer</span>(<span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>CancelFunc</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>killServer</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>killServer</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>server</span>: <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Addr</span>: <span style=color:#a6e22e>addr</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cancel</span>: <span style=color:#a6e22e>cancel</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>killServer</span>) <span style=color:#a6e22e>Start</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>Handler</span> = <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>ListenAndServe</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;KillServer Error:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>killServer</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusOK</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// cancel the context
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cancel</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our TestRun uses the same context to run the service.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestRun</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>())
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>killServer</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newKillServer</span>(<span style=color:#e6db74>&#34;:19999&#34;</span>, <span style=color:#a6e22e>cancel</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>killServer</span>.<span style=color:#a6e22e>Start</span>()  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>runService</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>killServer</span>.<span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>Shutdown</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To test out our killswitch locally, we can compile the service with: <code>go test -c ./ -cover -covermode=count -coverpkg=./...</code> to create a <code>.test</code> binary, and run it with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./my-service.test -test.coverprofile my-service.out
</span></span></code></pre></div><p>In another terminal, we run some tests and then kill it with the HTTP signal.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./run-tests.sh <span style=color:#75715e># here we could make test calls to the server.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl localhost:19999 <span style=color:#75715e># and then kill the remote server when were done</span>
</span></span></code></pre></div><p>Finally, a file named <code>my-service.out</code> should be created with coverage information from our server.</p><p>Using <code>go test -c</code> to build test binaries is a nice little trick I learned about recently. It plays nicely with containers too.</p><h2 id=part-2-running-in-our-kubernetes-cluster>Part 2: Running in our Kubernetes Cluster</h2><p>Now we can add them to our Dockerfile. Also, we&rsquo;re going to add a little wrapper script to restart them endlessly. If we let the entrypoint process end, our container and coverage files will be deleted after the killswitch is called, which is not what we want.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># server_with_restart.sh</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># this script passes arguments into server.test with</span>
</span></span><span style=display:flex><span><span style=color:#75715e># the addition of -test.coverprofile=cover.out</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> true; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Service started in coverage mode&#34;</span>
</span></span><span style=display:flex><span>    /server.test -test.coverprofile<span style=color:#f92672>=</span>cover.out <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>||</span> exit 1;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Server restarting..&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>We need a Dockerfile with the <code>server.test</code> binary, <code>curl</code>, and the restart script.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apk --no-cache add curl<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./server_with_restart.sh /server_with_restart.sh<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./server.test /server.test<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [ <span style=color:#e6db74>&#34;/server_with_restart.sh&#34;</span> ]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Next, build the new docker image and deploy it in your kubernetes cluster, possibly with helm. Make sure you don&rsquo;t so override the Dockerfile&rsquo;s entrypoint. However, you can pass args as usual into the deployment container, which will pass into the server.test command.</p><p>Next, run your tests. In our case, we built an integration testing program named <code>gandalf</code> that we run in our cluster:</p><pre tabindex=0><code>helm install gandalf ./deployments/gandalf
kubectl exec -it gandalf -- /gandalf-tests
</code></pre><p>Coverage will be recorded by the server.test.</p><h2 id=part-3-collecting-coverage>Part 3: Collecting Coverage</h2><p>Now to generate, download and merge our coverage.</p><p>To output the coverage we just have to send an HTTP request to our killserver on port 19999.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl exec my-service -- curl -s localhost:19999
</span></span></code></pre></div><p>Then copy the file to our local filesystem:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl exec -i my-service -- cat /cover.out &gt; cover/my-service.out
</span></span></code></pre></div><p>Do this for each service being tested, and then merge the coverage profiles together.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go install github.com/wadey/gocovmerge@latest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gocovmerge cover/*.out &gt; cover/merged.cov
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Output Total Coverage </span>
</span></span><span style=display:flex><span>go tool cover -func<span style=color:#f92672>=</span>cover/merged.cov | grep -E <span style=color:#e6db74>&#39;^total\:&#39;</span> | sed -E <span style=color:#e6db74>&#39;s/\s+/ /g&#39;</span>
</span></span></code></pre></div><p>Note: We use a <code>.cov</code> extention on the <code>merged.cov</code> to make it easy to use <code>cover/*.out</code> in scripting.</p><p>Inspect the contents of your new <code>merged.cov</code> file and try not to get drunk with power.</p><h3 id=conclusion>Conclusion</h3><p>Now our build pipeline prints out our integration test coverage percent collected from all our go services, and combined into a final figure.</p><p>For us at Manabie, we output this percent in our CI logs, and we set a rule that prevents pull requests from being mergeable if they decrease this percent.</p><p><a href=https://github.com/manabie-com/manabie-com.github.io/blob/main/content/posts/integration-test-code-coverage-in-go/examples>Example on Github</a></p><hr><footer><div class=meta_item><span class=meta_text>About <a href=/author/ds0nt>ds0nt</a></span><br><i>A developer who loves making things with golang, customizing his linux, and connecting too many displays</i><br><span class=meta_text><a href=https://www.linkedin.com/in/danielsont target=_blank>https://www.linkedin.com/in/danielsont</a></span></div><hr><section><h4>Share</h4><nav class="nav sharing-icons"><a class=nav-item href="https://www.facebook.com/sharer/sharer.php?u=%2f2021%2f12%2fintegration-test-code-coverage-in-go%2f" title="Share on Facebook"><span class="fab fa-facebook-f fa-2x" aria-hidden=true></span></a>
<a class=nav-item href="https://www.linkedin.com/shareArticle?mini=true&url=%2f2021%2f12%2fintegration-test-code-coverage-in-go%2f" title="Share on LinkedIn"><span class="fab fa-linkedin-in fa-2x" aria-hidden=true></span></a>
<a class=nav-item href="https://twitter.com/intent/tweet?url=%2f2021%2f12%2fintegration-test-code-coverage-in-go%2f&text=Test%20Coverage%20of%20Go%20Services%20during%20Integration%20Tests" title="Tweet this"><span class="fab fa-twitter fa-2x"></span></a></nav></section><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//manabie.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="col-sm-3 ml-auto blog-sidebar"><section class=sidebar-module><h4>Links</h4><ol class=list-unstyled><li><a href=https://manabie.com>About Us</a></li><li><a href=https://manabie.breezy.hr>Careers</a></li></ol></section></aside></div></div><footer class=blog-footer><p dir=auto>Except where otherwise noted, content on this site is licensed under a <a href=https://creativecommons.org/licenses/by-sa/4.0/>Creative Commons Attribution 4.0 International license</a>.</p><p><a href=#>Back to top</a></p></footer></body></html>